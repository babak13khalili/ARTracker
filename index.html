<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ردیاب دوچرخه AR</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; }
        video { position: absolute; width: 100vw; height: 100vh; object-fit: cover; }
        canvas { position: absolute; width: 100vw; height: 100vh; object-fit: cover; }
        #status { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; border-radius: 5px; z-index: 10; }
    </style>
</head>
<body>

    <div id="status">در حال بارگذاری هوش مصنوعی...</div>
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>

    <script type="module">
        import { ObjectDetector, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js";

        const video = document.getElementById("webcam");
        const canvas = document.getElementById("output_canvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");
        
        let objectDetector;
        let bicyclePath = []; // ذخیره مسیر دوچرخه

        // ۱. مقداردهی اولیه ردیاب گوگل
        async function initializeDetector() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/wasm"
            );
            objectDetector = await ObjectDetector.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite`,
                    delegate: "GPU"
                },
                scoreThreshold: 0.4, // حساسیت تشخیص
                runningMode: "VIDEO"
            });
            statusDiv.innerText = "هوش مصنوعی آماده است. دوربین را سمت یک دوچرخه بگیرید.";
            startCamera();
        }

        // ۲. فعال‌سازی دوربین
        async function startCamera() {
            const constraints = { video: { facingMode: "environment" } };
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
        }

        // ۳. تشخیص و ترسیم مسیر
        async function predictWebcam() {
            // تنظیم ابعاد کانواس بر اساس ویدیو
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;

            const startTimeMs = performance.now();
            const detections = await objectDetector.detectForVideo(video, startTimeMs);

            renderDetections(detections);
            window.requestAnimationFrame(predictWebcam);
        }

        function renderDetections(result) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            result.detections.forEach(detection => {
                const label = detection.categories[0].categoryName;
                
                // فقط اگر دوچرخه (bicycle) بود پردازش کن
                if (label === "bicycle") {
                    const { originX, originY, width, height } = detection.boundingBox;
                    
                    // محاسبه نقطه تماس چرخ با زمین
                    const posX = originX + (width / 2);
                    const posY = originY + height;

                    // اضافه کردن به تاریخچه مسیر
                    bicyclePath.push({ x: posX, y: posY });
                    if (bicyclePath.length > 100) bicyclePath.shift(); // محدود کردن طول خط
                }
            });

            // ۴. رسم خط مسیر
            if (bicyclePath.length > 2) {
                ctx.beginPath();
                ctx.strokeStyle = "#00ff00"; // رنگ سبز درخشان
                ctx.lineWidth = 5;
                ctx.lineJoin = "round";
                ctx.moveTo(bicyclePath[0].x, bicyclePath[0].y);
                
                for (let i = 1; i < bicyclePath.length; i++) {
                    ctx.lineTo(bicyclePath[i].x, bicyclePath[i].y);
                }
                ctx.stroke();
            }
        }

        initializeDetector();
    </script>
</body>
</html>